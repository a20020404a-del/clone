"""Manual Input API endpoints"""
from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse

from ..models.schemas import (
    ManualSpeakRequest,
    ManualSpeakResponse,
    ProcessingStatus,
    ErrorResponse
)
from ..services.voice_clone import VoiceCloneService
from ..services.avatar_gen import AvatarGeneratorService
from ..utils.file_handler import FileHandler

router = APIRouter()

# Service instances
voice_service = VoiceCloneService()
avatar_service = AvatarGeneratorService()
file_handler = FileHandler()

# Task storage
_manual_tasks: dict = {}


@router.post(
    "/speak",
    response_model=ManualSpeakResponse,
    responses={400: {"model": ErrorResponse}, 404: {"model": ErrorResponse}}
)
async def make_avatar_speak(request: ManualSpeakRequest):
    """
    Make the avatar speak custom text.

    This endpoint allows you to input specific text that the avatar
    will speak using the cloned voice.

    Set preview_only=True to generate only the audio without the video.
    """
    import uuid

    # Validate clone exists
    clone_status = await voice_service.get_clone_status(request.clone_id)
    if not clone_status:
        raise HTTPException(status_code=404, detail="Voice clone not found")

    # Validate image exists (unless preview_only)
    if not request.preview_only:
        image_path = avatar_service.get_image_path(request.image_id)
        if not image_path:
            raise HTTPException(status_code=404, detail="Reference image not found")

    # Create task
    task_id = str(uuid.uuid4())
    _manual_tasks[task_id] = {
        "status": ProcessingStatus.PROCESSING,
        "text": request.text,
        "clone_id": request.clone_id,
        "image_id": request.image_id,
        "preview_only": request.preview_only,
        "audio_url": None,
        "video_url": None
    }

    # Synthesize speech
    audio_id, audio_path, duration, audio_status, audio_msg = await voice_service.synthesize_speech(
        request.clone_id,
        request.text
    )

    if audio_status != ProcessingStatus.COMPLETED:
        _manual_tasks[task_id]["status"] = ProcessingStatus.FAILED
        raise HTTPException(status_code=400, detail=f"Audio synthesis failed: {audio_msg}")

    audio_url = f"/api/v1/voice/audio/{audio_id}"
    _manual_tasks[task_id]["audio_url"] = audio_url

    video_url = None

    # Generate video if not preview_only
    if not request.preview_only:
        image_path = avatar_service.get_image_path(request.image_id)
        video_id, video_status, video_msg = await avatar_service.generate_avatar(
            request.image_id,
            image_path,
            audio_path
        )

        if video_status == ProcessingStatus.COMPLETED:
            video_url = f"/api/v1/avatar/{video_id}/video"
            _manual_tasks[task_id]["video_url"] = video_url
        elif video_status == ProcessingStatus.FAILED:
            # Audio succeeded but video failed - partial success
            _manual_tasks[task_id]["status"] = ProcessingStatus.COMPLETED
            return ManualSpeakResponse(
                task_id=task_id,
                text=request.text,
                clone_id=request.clone_id,
                image_id=request.image_id,
                status=ProcessingStatus.COMPLETED,
                audio_url=audio_url,
                video_url=None
            )

    _manual_tasks[task_id]["status"] = ProcessingStatus.COMPLETED

    return ManualSpeakResponse(
        task_id=task_id,
        text=request.text,
        clone_id=request.clone_id,
        image_id=request.image_id,
        status=ProcessingStatus.COMPLETED,
        audio_url=audio_url,
        video_url=video_url
    )


@router.get("/{task_id}/status")
async def get_task_status(task_id: str):
    """
    Get the status of a manual speak task.
    """
    task = _manual_tasks.get(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    return {
        "task_id": task_id,
        "status": task["status"],
        "audio_url": task.get("audio_url"),
        "video_url": task.get("video_url")
    }


@router.get("/{task_id}/video")
async def get_task_video(task_id: str):
    """
    Get the video generated by a manual speak task.
    """
    task = _manual_tasks.get(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    if task["status"] != ProcessingStatus.COMPLETED:
        raise HTTPException(status_code=400, detail="Task not completed yet")

    video_url = task.get("video_url")
    if not video_url:
        raise HTTPException(status_code=404, detail="No video generated for this task")

    # Extract video_id from URL
    video_id = video_url.split("/")[-2]
    video_path = await avatar_service.get_video_path(video_id)

    if not video_path:
        raise HTTPException(status_code=404, detail="Video file not found")

    return FileResponse(
        video_path,
        media_type="video/mp4",
        filename=f"avatar_{task_id}.mp4"
    )


@router.delete("/{task_id}")
async def cancel_task(task_id: str):
    """
    Cancel a manual speak task.

    Note: This only removes the task from tracking.
    Files that have already been generated will remain.
    """
    if task_id not in _manual_tasks:
        raise HTTPException(status_code=404, detail="Task not found")

    task = _manual_tasks[task_id]

    # Can only cancel pending/processing tasks
    if task["status"] == ProcessingStatus.COMPLETED:
        return {"status": "already_completed", "task_id": task_id}

    del _manual_tasks[task_id]
    return {"status": "cancelled", "task_id": task_id}


@router.post("/preview")
async def preview_speech(
    text: str,
    clone_id: str
):
    """
    Generate an audio preview without video.

    This is a quick way to hear how the text will sound
    before generating the full avatar video.
    """
    # Validate clone exists
    clone_status = await voice_service.get_clone_status(clone_id)
    if not clone_status:
        raise HTTPException(status_code=404, detail="Voice clone not found")

    # Synthesize speech
    audio_id, audio_path, duration, status, msg = await voice_service.synthesize_speech(
        clone_id,
        text
    )

    if status != ProcessingStatus.COMPLETED:
        raise HTTPException(status_code=400, detail=f"Audio synthesis failed: {msg}")

    return {
        "audio_id": audio_id,
        "audio_url": f"/api/v1/voice/audio/{audio_id}",
        "duration": duration,
        "text": text
    }


@router.get("/tasks")
async def list_tasks():
    """
    List all manual speak tasks.
    """
    return {
        "tasks": [
            {
                "task_id": task_id,
                "status": task["status"],
                "text": task["text"][:50] + "..." if len(task["text"]) > 50 else task["text"],
                "has_video": task.get("video_url") is not None
            }
            for task_id, task in _manual_tasks.items()
        ]
    }
